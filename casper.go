/*
Package casper implements H2O's [1] CASPer (cache-aware server push) in golang.

It wraps go's standard server push method and maintains a fingerprint of browser caches and decides to push or cancel. The fingerprint is generated by using golomb-coded sets (compressed encoding of Bloom filter).

[1]: https://github.com/h2o/h2o

Below is a simple example of usage.

  // Initialize casper with false-positive probability
  // 1/64 and number of assets 10.
  pusher := casper.New(1<<6, 10)

  http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {

      // Execute cache aware server push.
      //
      // In this example, it generates a fingerprint "JA" and set it
      // as "x-go-casper" cookie value.
      //
      // If you access this handler first time, it runs server-push.
      // But from next time, with same client, it cancels pushing since
      // cookie indicates asset has already been cached by the client.
      if _, err := pusher.Push(w, r, []string{"/static/example.js"}, nil); err != nil {
          log.Printf("[ERROR] Failed to push assets: %s", err)
      }

      // ...
  })

*/
package casper

import (
	"bytes"
	"crypto/md5"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"net/http"
	"sort"
	"strconv"
	"strings"

	"github.com/tcnksm/go-casper/internal/encoding/golomb"
)

const (
	// defaultCookieName is default cookie name for storing
	// a fingerprint of asset files being cached by the browser.
	defaultCookieName = "x-go-casper"

	// defaultCookiePath is default cookie path to be used for
	// generating cookie to return.
	defaultCookiePath = "/"
)

// Casper provides a interface for cache-aware HTTP/2 server push.
type Casper struct {
	p uint
	n uint

	// skipPush decides executing actual server push or not. This should
	// be used only in testing.
	//
	// Currently, it's kinda hard to receive http push in go http client.
	// This should be removed in future.
	skipPush bool
}

// hash generate a hash value from the given bytes for
// n elements and p faslse positive probability.
//
// It's ok to use md5 since we just need a hash that generates
// uniformally-distributed values for best results.
func (c *Casper) hash(p []byte) uint {
	h := md5.New()
	h.Write(p)
	b := h.Sum(nil)

	s := hex.EncodeToString(b[12:16])
	i, err := strconv.ParseUint(s, 16, 32)
	if err != nil {
		panic(err)
	}
	return uint(i) % (c.n * c.p)
}

// generateCookie generates cookie from the given hash values.
func (c *Casper) generateCookie(hashValues []uint) (*http.Cookie, error) {

	// golomb encoder expect the given array is sorted.
	sort.Slice(hashValues, func(i, j int) bool {
		return hashValues[i] < hashValues[j]
	})

	var buf bytes.Buffer
	encoder := base64.NewEncoder(base64.RawURLEncoding, &buf)
	if err := golomb.Encode(encoder, hashValues, c.p); err != nil {
		return nil, fmt.Errorf("failed golomb coding: %s", err)
	}

	if err := encoder.Close(); err != nil {
		return nil, fmt.Errorf("failed to close encoder: %s", err)
	}

	return &http.Cookie{
		Name:  defaultCookieName,
		Value: buf.String(),

		Path: defaultCookiePath,
	}, nil
}

// readCookie reads cookie from http request and decode it to hash array.
func (c *Casper) readCookie(r *http.Request) ([]uint, error) {
	cookie, err := r.Cookie(defaultCookieName)
	if err != nil && err != http.ErrNoCookie {
		return nil, fmt.Errorf("failed to read cookie: %s", err)
	}

	if err == http.ErrNoCookie {
		hashValues := make([]uint, 0, c.n)
		return hashValues, nil
	}

	// Decode golomb coded cookie value to original hash values array.
	decoder := base64.NewDecoder(base64.RawURLEncoding, strings.NewReader(cookie.Value))
	hashValues, err := golomb.DecodeAll(decoder, c.p)
	if err != nil {
		return nil, fmt.Errorf("failed golomb decoding: %s", err)
	}

	return hashValues, nil
}

// search looks up the provided slices contains the given value.
//
// TODO(tcnksm): binary search (or enable to configure?)
func search(a []uint, h uint) bool {
	for i := 0; i < len(a); i++ {
		if h == a[i] {
			return true
		}

		if h < a[i] {
			return false
		}
	}
	return false
}
